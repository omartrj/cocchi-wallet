<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>$COCCHI Wallet - Login</title>
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="public/images/coin.svg">
    <!-- My custom CSS -->
    <!-- <link href="public/css/style.css" rel="stylesheet"> -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Poppins", sans-serif;
            color: #505050;
        }

        body {
            background-color: #f4f4f4;
        }

        .view {
            display: flex;
            flex-direction: column;
        }

        #container {
            width: 400px;
            top: 50%;
            left: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            background-color: #dfe7fd;
            padding: 20px;
            border: 1px solid rgba(0, 0, 0, 0.058);
            border-radius: 15px;
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
            text-align: center;
        }

        #title {
            margin-bottom: 20px;
        }

        #title img:hover {
            transform: rotate(360deg);
            transition: 0.5s;
        }

        #title img {
            width: 100px;
            height: 100px;
            margin-bottom: 10px;
            transition: 0.5s;
            border-radius: 50%;
        }

        #title h1 {
            color: #5650d2;
            font-size: 40px;
            font-weight: 500;
        }

        #title .token {
            font-weight: 300;
            font-size: 35px;
            margin-right: 10px;
        }


        #title .token::after {
            content: "$";
            font-size: 25px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            background-color: white;
            padding: 10px 20px;
            border-radius: 15px;
        }

        .input-group label {
            font-size: 15px;
            font-weight: 400;
            margin-bottom: 5px;
            text-align: left;
        }

        .input-container {
            display: flex;
            align-items: center;
        }

        .input-icon {
            margin-right: 10px;
            /* Adjust the margin as needed */
            width: 25px;
        }

        .input-container input {
            width: 100%;
            height: 40px;
            border: none;
            outline: none;
            background-color: transparent;
            font-size: 14px;
            font-weight: 300;
        }

        .input-container input::placeholder {
            color: #a7a7a7;
        }

        .button {
            background-color: #5650d2;
            transition: 0.3s;
            color: white;
            cursor: pointer;
            border: none;
            outline: none;
        }

        .button:hover {
            background-color: #413ca0;
        }

        .full-button {
            width: 100%;
            padding: 10px;
            font-size: 15px;
            font-weight: 400;
            border-radius: 30px;
        }

        #login-button {
            margin-top: 20px;
        }

        #or {
            font-size: 15px;
            font-weight: 400;
            margin: 15px auto;
            width: 50px;
            text-align: center;
            position: relative;
        }

        #or hr {
            border: none;
            border-top: 1px solid #a7a7a7;
        }

        #dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(0, 0, 0, 0.058);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
        }

        #dialog-title {
            font-size: 20px;
            font-weight: 500;
            margin-bottom: 10px;
        }

        #dialog.error #dialog-title::before {
            content: "‚ùå ";
            font-size: 20px;
            font-weight: 500;
        }

        #dialog.success #dialog-title::before {
            content: "‚úÖ ";
            font-size: 20px;
            font-weight: 500;
        }

        #dialog.warning #dialog-title::before {
            content: "‚ö†Ô∏è ";
            font-size: 20px;
            font-weight: 500;
        }

        #dialog-message {
            font-size: 16px;
            font-weight: 300;
            margin-bottom: 20px;
        }

        #dialog-message strong {
            font-weight: 500;
        }

        #dialog-message a {
            color: #5650d2;
            font-weight: 400;
            text-decoration: none;
        }

        #dialog-message a:hover {
            text-decoration: underline;
        }

        #dialog-message a:visited {
            color: #5650d2;
        }

        #dialog::backdrop {
            background-color: rgba(0, 0, 0, 0.4);
        }

        #dialog-button {
            max-width: 100px;
        }

        #dialog-spinner {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin: auto;
            margin-bottom: 20px;
            display: none;
            animation: rotate 1s linear infinite;
        }

        #dialog.warning #dialog-button {
            display: none;
        }

        #dialog.warning #dialog-spinner {
            display: block;
        }

        #address {
            border-radius: 20px;
            cursor: pointer;
            margin: auto;
            display: flex;
            align-items: center;
            padding: 8px 15px;
            z-index: 2;
        }

        #address span {
            color: #cbdaff;
            font-size: 13px;
            font-weight: 400;
            margin-right: 10px;
        }

        #address-tooltip {
            position: absolute;
            background-color: #505050;
            padding: 5px 10px;
            border-radius: 10px;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: 0.3s;
            z-index: -1;
        }

        #address-tooltip::before {
            content: "";
            position: absolute;
            top: -16px;
            left: 50%;
            transform: translateX(-50%);
            border: 10px solid transparent;
            border-bottom-color: #505050;
        }

        #address-tooltip p {
            color: white;
            font-size: 11px;
            font-weight: 300;
        }

        #transaction-buttons {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            gap: 10px;
            margin: 20px 0;
        }

        .transaction-button {
            width: 50%;
            padding: 10px;
            font-size: 15px;
            font-weight: 400;
            border-radius: 20px;
        }

        #input-target-address {
            margin-bottom: 20px;
        }

        #balance-container {
            display: flex;
            flex-direction: row;
            align-items: baseline;
            margin: 20px auto;
        }

        #refresh-button {
            height: 30px;
            align-self: self-start;
            background-color: transparent;
            outline: none;
            cursor: pointer;
            border-radius: 30%;
            padding: 5px;
            transition: padding 0.3s;
        }

        #refresh-button:hover {
            /* transform: rotate(360deg); */
            padding: 3px;
            transition: padding 0.3s;
        }

        @keyframes rotate {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #balance {
            font-size: 45px;
            font-weight: 400;
            margin-right: 10px;
        }

        #currency {
            font-size: 25px;
        }

        #currency.token {
            font-size: 30px;
            margin-right: 10px;
            font-weight: 300;
        }

        #currency.token::after {
            content: "$";
            font-size: 20px;
        }

        #logout-button {
            background-color: transparent;
            border: none;
            outline: none;
            cursor: pointer;
            width: fit-content;
            margin: auto;
            padding: 0 10px;
        }

        #logout-button:hover {
            color: #5650d2;
        }

        #logout-button::before {
            content: "ü°†";
            font-size: 15px;
            margin-right: 5px;
            transition: 0.3s;
        }

        #logout-button:hover::before {
            margin-left: -15px;
            margin-right: 20px;
            transition: 0.3s;
        }

        @media (max-width: 500px) {
            #container {
                width: 90%;
            }

            #dialog {
                width: 90%;
            }

            #title img:hover {
                transform: none;
            }

            #logout-button::before {
                content: "‚Üê";
            }

        }
    </style>
    <!-- Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
        rel="stylesheet">
    <!-- Web3 JS -->
    <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
    <!-- My custom JS -->
    <!-- <script src="public/js/script.js" defer></script> -->
</head>

<body>
    <div id="container">

        <!-- LOGIN VIEW -->
        <div class="view" id="login-view">
            <!-- TITLE AND LOGO -->
            <div id="title">
                <img src="public/images/coin.svg" alt="coin">
                <h1><span class="token">COCCHI</span>Wallet</h1>
            </div>
            <!-- PRIVATE KEY INPUT -->
            <div class="input-group" id="input-private-key">
                <label for="private-key">Private Key</label>
                <div class="input-container" id="input-container-private-key">
                    <img class="input-icon" id="private-key-icon" src="public/images/lock-solid.svg" alt="key">
                    <input type="password" id="private-key" name="private-key" placeholder="0x0000 ... 0000">
                </div>
            </div>
            <!-- LOGIN BUTTON -->
            <button class="full-button button" id="login-button">Login</button>
            <!-- "OR" SECTION -->
            <div id="or">
                <hr>
                <p>OR</p>
                <hr>
            </div>
            <!-- METAMASK BUTTON -->
            <button class="full-button button" id="metamask-button">Login with MetaMask</button>
        </div>

        <!-- WALLET VIEW -->
        <div class="view" id="wallet-view" style="display: none; opacity: 0;">
            <!-- CURRENT PUBLIC ADDRESS -->
            <button id="address" class="button">
                <span></span>
                <img src="public/images/copy-solid.svg" alt="copy" height="20px">
            </button>
            <!-- ADDRESS TOOLTIP -->
            <div id="address-tooltip">
                <p></p>
            </div>
            <!-- BALANCE -->
            <div id="balance-container">
                <img src="public/images/arrows-rotate-solid.svg" alt="refresh" id="refresh-button">
                <span id="balance"></span>
                <span id="currency" class="token">CCH</span>
            </div>
            <!-- TARGET PUBLIC ADDRESS INPUT -->
            <div class="input-group" id="input-target-address">
                <label for="target-address">Target Address</label>
                <div class="input-container" id="input-container-target-address">
                    <img class="input-icon" id="target-address-icon" src="public/images/lock-open-solid.svg" alt="user">
                    <input type="text" id="target-address" name="target-address" placeholder="0x0000 ... 0000">
                </div>
            </div>
            <!-- AMOUNT INPUT -->
            <div class="input-group" id="input-amount">
                <label for="amount">Amount</label>
                <div class="input-container" id="input-container-amount">
                    <img class="input-icon" id="amount-icon" src="public/images/coin.svg" alt="token">
                    <input type="number" id="amount" name="amount" placeholder="50" min="1" step="1">
                </div>
            </div>
            <!-- BUTTONS SECTION -->
            <div id="transaction-buttons">
                <button class="transaction-button button" id="balance-button">Balance</button>
                <button class="transaction-button button" id="send-button">Send</button>
                <button class="transaction-button button" id="mint-button">Mint</button>
            </div>
            <!-- LOGOUT -->
            <button id="logout-button">Logout</button>
        </div>

        <!-- DIALOG -->
        <dialog id="dialog">
            <h3 id="dialog-title"></h3>
            <p id="dialog-message"></p>
            <img id="dialog-spinner" src="public/images/spinner-solid.svg" alt="spinner">
            <button class="full-button button" id="dialog-button" autofocus onlcick="closeDialog()">Close</button>
        </dialog>
    </div>

    <script>
        const testnet = "https://rpc2.sepolia.org/"
        const web3 = new Web3(new Web3.providers.HttpProvider(testnet))

        const contractAddress = "0xa557589cD7BDA38C2a985649656F56dC4cDbb6be";
        const contractJsonInterface = [
            { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" },
            { "inputs": [{ "internalType": "uint256", "name": "requested", "type": "uint256" }, { "internalType": "uint256", "name": "available", "type": "uint256" }], "name": "InsufficientBalance", "type": "error" },
            { "inputs": [{ "internalType": "address", "name": "receiver", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "mint", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "address", "name": "receiver", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "send", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "address", "name": "from", "type": "address" }, { "indexed": false, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "Sent", "type": "event" },
            { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "balances", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
            { "inputs": [], "name": "minter", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }
        ];
        const contract = new web3.eth.Contract(contractJsonInterface, contractAddress);

        let currentPublicAddress = "";
        let usedMetamask = false;
        let currentPrivateKey = "";

        const inputPrivateKeyElement = document.querySelector("#private-key");
        const loginButtonElement = document.querySelector("#login-button");
        const metamaskButtonElement = document.querySelector("#metamask-button");
        const logoutButtonElement = document.querySelector("#logout-button");
        const addressElement = document.querySelector("#address");
        const addressTooltipElement = document.querySelector("#address-tooltip");
        const balanceElement = document.querySelector("#balance");
        const refreshButtonElement = document.querySelector("#refresh-button");
        const inputTargetAddressElement = document.querySelector("#target-address");
        const inputAmountElement = document.querySelector("#amount");
        const sendButtonElement = document.querySelector("#send-button");
        const mintButtonElement = document.querySelector("#mint-button");
        const balanceButtonElement = document.querySelector("#balance-button");
        const dialogElement = document.querySelector("#dialog");

        /* Funzione per switchare tra le pagine */
        function show(shown, hidden) {
            document.getElementById(shown).style.opacity = '1';
            document.getElementById(shown).style.display = 'flex';
            document.head.querySelector("title").textContent = "$COCCHI Wallet - " + shown.charAt(0).toUpperCase() + shown.slice(1, -5);

            document.getElementById(hidden).style.opacity = '0';
            document.getElementById(hidden).style.display = 'none';

            //Svuota i campi input
            inputTargetAddressElement.value = "";
            inputAmountElement.value = "";
            inputPrivateKeyElement.value = "";

            return false;
        }

        /* Funzione per rendere valido l'indirizzo */
        function validateAddress(address) {
            let validAddress = "";
            if (address.startsWith("0x")) {
                address = address.slice(2);
            }
            validAddress = "0x" + address.toUpperCase();
            return validAddress;
        }

        /* Funzione per il login */
        async function login(privateKey) {
            showDialog({ type: "warning", title: "Login in progress", message: "Please wait." });
            const account = web3.eth.accounts.privateKeyToAccount(privateKey);
            currentPublicAddress = account.address;
            currentPrivateKey = privateKey;
            currentPublicAddress = validateAddress(currentPublicAddress);
            updateAddress();
            await updateBalance();
            usedMetamask = false;
        }

        loginButtonElement.addEventListener("click", async () => {
            let privateKey = inputPrivateKeyElement.value;
            //Se la chiave privata non inizia con 0x, la aggiungo
            if (!privateKey.startsWith("0x")) {
                privateKey = "0x" + privateKey;
            }
            try {
                await login(privateKey);
                show("wallet-view", "login-view");
                closeDialog();
            } catch (error) {
                showDialog({ type: "error", title: "Login error", message: error.message });
            }
        });

        /* Funzione per il login con metamask */
        metamaskButtonElement.addEventListener("click", async () => {
            showDialog({ type: "warning", title: "Login in progress", message: "Please connect your MetaMask wallet." });
            try {
                const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                currentPublicAddress = accounts[0];
                //Rendi la currentPublicAddress maiuscola tranne 0x
                currentPublicAddress = validateAddress(currentPublicAddress);
                updateAddress();
                await updateBalance();
                show("wallet-view", "login-view");
                usedMetamask = true;
                closeDialog();
            } catch (error) {
                showDialog({ type: "error", title: "Login error", message: "MetaMask wallet not connected." });
            }
        });

        function shortenAddress(address) {
            return address.slice(0, 6) + "..." + address.slice(-4);
        }

        /* Funzione per il logout */
        logoutButtonElement.addEventListener("click", async () => {
            currentPublicAddress = "";
            currentPrivateKey = "";
            usedMetamask = false;
            show("login-view", "wallet-view");
        });

        /* Funzione per mostrare l'indirizzo */
        function updateAddress() {
            // Abbrevia l'indirizzo
            let address = shortenAddress(currentPublicAddress);
            addressElement.querySelector("span").textContent = address;
        }

        /* Funzione per recuperare il saldo */
        async function getBalance(targetAddress, fromAddress = currentPublicAddress) {
            const balance = await contract.methods.balances(targetAddress).call({ from: fromAddress });
            return balance;
        }

        /* Funzione per mostrare il saldo */
        async function updateBalance() {
            const balance = await getBalance(currentPublicAddress);
            balanceElement.textContent = balance;
        }

        /* Funzione per gestire il click sul bottone "Balance" */
        balanceButtonElement.addEventListener("click", async () => {
            showDialog({ type: "warning", title: "Transaction in progress", message: "Please wait while the balance is being retrieved." });
            const targetAddress = inputTargetAddressElement.value;
            const balance = await getBalance(targetAddress);
            showDialog({ type: "success", title: "Balance", message: `The current balance of ${getHref({ type: "address", string: targetAddress })} is <strong>${balance} CCH</strong>` });
        });

        /* Funzione per gestire il click sul bottone "Refresh" */
        let interval;
        refreshButtonElement.addEventListener("click", async () => {
            let updated = false;
            updateBalance().then(() => {
                updated = true;
            });
            refreshButtonElement.style.animation = "rotate 1s linear";
            interval = setInterval(() => {
                if (!updated) {
                    refreshButtonElement.style.animation = "rotate 1s linear";
                } else {
                    refreshButtonElement.style.animation = "none";
                    clearInterval(interval);
                }
            }, 1000);
        });


        /* Funzioni per gestire il dialog */
        function showDialog({ type, title, message }) {
            //If the dialog is already open, close it and open a new one
            if (dialogElement.open) {
                dialogElement.close();
            }
            dialogElement.classList.remove("error", "warning", "success");
            dialogElement.classList.add(type);
            dialogElement.querySelector("h3").textContent = title;
            dialogElement.querySelector("p").innerHTML = message;
            dialogElement.showModal();

        }
        function closeDialog() {
            dialogElement.close();
        }
        dialogElement.querySelector("button").addEventListener("click", closeDialog);

        /* Funzione per mostrare il tooltip */
        addressElement.addEventListener("mouseenter", () => {
            addressTooltipElement.querySelector("p").textContent = "Copy to clipboard";
            addressTooltipElement.style.opacity = "1";
            addressTooltipElement.style.top = "60px";
            addressTooltipElement.style.zIndex = "1";
        });

        /* Funzione per nascondere il tooltip */
        addressElement.addEventListener("mouseleave", () => {
            addressTooltipElement.style.opacity = "0";
            addressTooltipElement.style.top = "40px";
            addressTooltipElement.style.zIndex = "-1";
        });

        /* Funzione per gestire il click sull'indirizzo */
        addressElement.addEventListener("click", () => {
            navigator.clipboard.writeText(currentPublicAddress);
            addressTooltipElement.querySelector("p").textContent = "Copied!";
        });

        /* Funzione per mostrare le informazioni della ricevuta */
        function showReceiptInfo(receipt, receiverAddress, amount) {
            let receiptType = "";
            let receiptTitle = "";
            let receiptMessage = "";
            if (receipt.status) {
                receiptType = "success";
                receiptTitle = "Transaction successful";
                receiptMessage =
                    `<strong>Contract Address:</strong> ${getHref({ type: "address", string: receipt.to })}<br>
            <strong>Block Hash:</strong> ${getHref({ type: "block", string: receipt.blockHash })}<br>
            <strong>Block Number:</strong> ${receipt.blockNumber}<br>
            <strong>Transaction Hash:</strong> ${getHref({ type: "tx", string: receipt.transactionHash })}<br>
            <strong>Transaction Index:</strong> ${receipt.transactionIndex}<br>
            <strong>From:</strong> ${getHref({ type: "address", string: receipt.from })}<br>
            <strong>To:</strong> ${getHref({ type: "address", string: receiverAddress })}<br>
            <strong>Amount:</strong> ${amount} CCH<br>
            <strong>Gas Used:</strong> ${receipt.gasUsed}`
            }
            else {
                receiptType = "error";
                receiptTitle = "Transaction failed";
                receiptMessage = "The transaction has been reverted by the network.";
            }
            showDialog({ type: receiptType, title: receiptTitle, message: receiptMessage });

        };

        function getLinkToEtherscan({ type, string }) {
            // type: "tx" | "address" | "block"
            return `https://sepolia.etherscan.io/${type}/${string}`;
        }

        function getHref({ type, string }) {
            let textContent = shortenAddress(validateAddress(string));
            let link = '<a href="' + getLinkToEtherscan({ type, string }) + '" target="_blank">' + textContent + '</a>';
            return link;
        }

        /* Funzione per creare una transazione di Send */
        async function createSendTransaction(receiverAddress, amount) {

            const estimatedGasConsumption = await contract.methods.send(receiverAddress, amount).estimateGas({ from: currentPublicAddress })
            const estimatedGasPrice = await web3.eth.getGasPrice()
            const sendCallDataABI = await contract.methods.send(receiverAddress, amount).encodeABI()
            const transactionCount = await web3.eth.getTransactionCount(currentPublicAddress)

            let sendTransaction = {};
            if (!usedMetamask) {
                sendTransaction = {
                    from: currentPublicAddress,
                    to: contractAddress,
                    value: 0,
                    gas: estimatedGasConsumption + estimatedGasConsumption,
                    gasPrice: estimatedGasPrice,
                    nonce: transactionCount,
                    data: sendCallDataABI
                }
            } else {
                sendTransaction = {
                    from: currentPublicAddress,
                    to: contractAddress,
                    value: 0,
                    data: sendCallDataABI
                }
            }

            return sendTransaction

        }

        async function send(receiverAddress, amount) {
            if (!usedMetamask) {
                const sendTransaction = await createSendTransaction(receiverAddress, amount);
                const signedTransaction = await web3.eth.accounts.signTransaction(sendTransaction, currentPrivateKey);
                web3.eth.sendSignedTransaction(signedTransaction.rawTransaction)
                    .on('receipt', receipt => {
                        showReceiptInfo(receipt, receiverAddress, amount);
                        updateBalance();
                    });
                updateBalance();
            } else {
                const sendTransaction = await createSendTransaction(receiverAddress, amount);
                ethereum.request({ method: 'eth_sendTransaction', params: [sendTransaction] })
                    .then(transactionHash => {
                        //every 15 seconds, check if the transaction exists
                        const interval = setInterval(async () => {
                            const transaction = await web3.eth.getTransaction(transactionHash);
                            if (transaction) {
                                clearInterval(interval);
                                const receipt = await web3.eth.getTransactionReceipt(transactionHash);
                                showReceiptInfo(receipt, receiverAddress, amount);
                                updateBalance();
                            }
                        }, 15000);
                    });
                updateBalance();
            }
        }

        /* Funzione per gestire il click sul bottone "Send" */
        sendButtonElement.addEventListener("click", async () => {
            const amount = inputAmountElement.value;
            if (amount <= 0) {
                showDialog({ type: "error", title: "Transaction error", message: "The amount must be greater than 0." });
                return;
            }
            showDialog({ type: "warning", title: "Transaction in progress", message: "Please wait while the 'SEND' transaction is being processed." });
            const receiverAddress = validateAddress(inputTargetAddressElement.value);

            try {
                await send(receiverAddress, amount);
            } catch (error) {
                showDialog({ type: "error", title: "Transaction error", message: error.message });
            }
        });

        /* Funzione per creare una transazione di Mint */
        async function createMintTransaction(receiverAddress, amount) {
            const estimatedGasConsumption = await contract.methods.mint(receiverAddress, amount).estimateGas({ from: currentPublicAddress })
            const estimatedGasPrice = await web3.eth.getGasPrice()
            const mintCallDataABI = await contract.methods.mint(receiverAddress, amount).encodeABI()
            const transactionCount = await web3.eth.getTransactionCount(currentPublicAddress)

            let mintTransaction = {};
            if (!usedMetamask) {
                mintTransaction = {
                    from: currentPublicAddress,
                    to: contractAddress,
                    value: 0,
                    gas: estimatedGasConsumption + estimatedGasConsumption,
                    gasPrice: estimatedGasPrice,
                    nonce: transactionCount,
                    data: mintCallDataABI
                }
            } else {
                mintTransaction = {
                    from: currentPublicAddress,
                    to: contractAddress,
                    value: 0,
                    data: mintCallDataABI
                }
            }

            return mintTransaction
        }

        async function mint(receiverAddress, amount) {
            const mintTransaction = await createMintTransaction(receiverAddress, amount);
            if (!usedMetamask) {
                const signedTransaction = await web3.eth.accounts.signTransaction(mintTransaction, currentPrivateKey);
                web3.eth.sendSignedTransaction(signedTransaction.rawTransaction)
                    .on('receipt', receipt => {
                        showReceiptInfo(receipt, receiverAddress, amount);
                        updateBalance();
                    });
                updateBalance();
            } else {
                ethereum.request({ method: 'eth_sendTransaction', params: [mintTransaction] })
                    .then(transactionHash => {
                        //every 15 seconds, check if the transaction exists
                        const interval = setInterval(async () => {
                            const transaction = await web3.eth.getTransaction(transactionHash);
                            if (transaction) {
                                clearInterval(interval);
                                const receipt = await web3.eth.getTransactionReceipt(transactionHash);
                                showReceiptInfo(receipt, receiverAddress, amount);
                                updateBalance();
                            }
                        }, 15000);
                    });
                updateBalance();
            }
        }

        /* Funzione per gestire il click sul bottone "Mint" */
        mintButtonElement.addEventListener("click", async () => {
            const amount = inputAmountElement.value;
            if (amount <= 0) {
                showDialog({ type: "error", title: "Transaction error", message: "The amount must be greater than 0." });
                return;
            }
            showDialog({ type: "warning", title: "Transaction in progress", message: "Please wait while the 'MINT' transaction is being processed." });
            const receiverAddress = validateAddress(inputTargetAddressElement.value);
            try {
                await mint(receiverAddress, amount);
            } catch (error) {
                showDialog({ type: "error", title: "Transaction error", message: error.message });
            }
        });



    </script>

</body>

</html>